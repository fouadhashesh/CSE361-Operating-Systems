/*
 * router_monitor.c
 * * Purpose: 
 * Runs as a background process to monitor and fetch data from the remote router.
 * It sleeps to save CPU but wakes up immediately when the Bash CLI script 
 * sends a signal (IPC) indicating that changes were applied.
 */

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>   // Required for signal handling (SIGUSR1, SIGTERM)
#include <unistd.h>   // Required for sleep(), getpid()
#include <string.h>
#include <time.h>     // Required for timestamping logs

/* * Global Flags for IPC
 * * 'volatile': Tells the compiler not to optimize/cache these variables, as they 
 * can change at any time outside the normal flow (by the signal handler).
 * 'sig_atomic_t': An integer type that guarantees atomic access, ensuring data 
 * doesn't get corrupted if a signal interrupts a read/write operation.
 */
volatile sig_atomic_t update_request = 0;
volatile sig_atomic_t stop_request = 0;

/*
 * Signal Handler for SIGUSR1
 * * Triggered by the Bash script command: `kill -SIGUSR1 [PID]`
 * We keep this handler extremely short. We only set a flag here.
 * Heavy lifting (networking/IO) is done in the main loop to avoid 
 * race conditions or deadlocks inside the interrupt context.
 */
void handle_sigusr1(int sig) {
    update_request = 1;
}

/*
 * Signal Handler for Shutdown (SIGTERM/SIGINT)
 * * Triggered when the script exits or user presses Ctrl+C.
 */
void handle_sigterm(int sig) {
    stop_request = 1;
}

// Helper: Prints messages with a readable timestamp like [2025-12-30 10:00:00]
void log_with_timestamp(const char* msg) {
    time_t now;
    time(&now);
    char buf[20];
    strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", localtime(&now));
    printf("[%s] [MONITOR] %s\n", buf, msg);
}

// Helper: Reads a file line-by-line and logs it (used to show local config state)
void log_file_content(const char* filepath, const char* label) {
    FILE* fp = fopen(filepath, "r");
    if (!fp) return;

    char line[256];
    while (fgets(line, sizeof(line), fp)) {
        // Remove trailing newline character to format log cleanly
        line[strcspn(line, "\n")] = 0;
        
        time_t now;
        time(&now);
        char buf[20];
        strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", localtime(&now));
        printf("[%s] [MONITOR] %s: %s\n", buf, label, line);
    }
    fclose(fp);
}

/*
 * read_config_value
 * * Parses the "key=value" file generated by the Bash script (router_cli.conf).
 * This allows the C program to know the current IP, User, and Password 
 * without hardcoding them.
 */
int read_config_value(const char* filepath, const char* key, char* dest, size_t dest_size) {
    FILE* fp = fopen(filepath, "r");
    if (!fp) return 0;

    char line[256];
    int found = 0;
    size_t key_len = strlen(key);
    
    while (fgets(line, sizeof(line), fp)) {
        // Check if line starts with key and is followed by '='
        if (strncmp(line, key, key_len) == 0 && line[key_len] == '=') {
            // Found key="val\n"
            char* val = line + key_len + 1; // Pointer to the value part
            val[strcspn(val, "\n")] = 0;    // Trim newline
            
            // Safe string copy to destination buffer
            strncpy(dest, val, dest_size - 1);
            dest[dest_size - 1] = '\0';
            found = 1;
            break;
        }
    }
    fclose(fp);
    return found;
}

/*
 * fetch_remote_config
 * * The core logic: Uses SSH to run commands on the router and reads the output.
 */
void fetch_remote_config() {
    // Default values (fallback)
    char ip[64] = "192.168.1.2"; 
    char port[16] = "22";
    char user[64] = "root";
    char pass[64] = "root";
    
    // 1. Read the latest credentials from the shared config file
    //    (The Bash script writes to this file before signaling us)
    read_config_value("state/router_cli.conf", "router_ip", ip, sizeof(ip));
    read_config_value("state/router_cli.conf", "router_port", port, sizeof(port));
    read_config_value("state/router_cli.conf", "username", user, sizeof(user));
    read_config_value("state/router_cli.conf", "password", pass, sizeof(pass));

    // 2. Construct the SSH command string dynamically
    //    Using 'sshpass' to handle the password non-interactively.
    //    Executes two remote commands: `uci show ...hostname` and `ip address show`
    char cmd[1024];
    snprintf(cmd, sizeof(cmd), 
             "sshpass -p '%s' ssh -o StrictHostKeyChecking=no -o HostKeyAlgorithms=+ssh-rsa -o PubkeyAcceptedKeyTypes=+ssh-rsa -p %s %s@%s \"echo '--- Remote Hostname ---'; uci show system.@system[0].hostname; echo '--- Remote Interfaces ---'; ip address show\" 2>&1",
             pass, port, user, ip);

    // 3. popen() executes the shell command and opens a pipe to read its output
    FILE* fp = popen(cmd, "r");
    if (!fp) {
        log_with_timestamp("Error: Failed to execute remote fetch command.");
        return;
    }

    // 4. Read the SSH output line by line and print it to our log
    char line[512];
    while (fgets(line, sizeof(line), fp)) {
        line[strcspn(line, "\n")] = 0; // Clean up newline
        
        time_t now;
        time(&now);
        char buf[20];
        strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", localtime(&now));
        
        printf("[%s] [MONITOR] REMOTE: %s\n", buf, line);
    }
    
    // 5. Close the pipe
    int status = pclose(fp);
    if (status != 0) {
        log_with_timestamp("Warning: Remote fetch command finished with errors (or mock mode/network issue).");
    }
}

// Wrapper function called when update signal is received
void fetch_router_updates() {
    log_with_timestamp("Received signal. Fetching REAL updates from router...");
    
    // Fetch live data via SSH
    fetch_remote_config();
    
    // Also log the local 'router_cli.conf' content to verify consistency
    log_with_timestamp("Local State (for comparison):");
    log_file_content("state/router_cli.conf", "Config");
    
    printf("\n"); // Visual Separator in log
}

int main() {
    printf("[MONITOR] Starting router monitor (PID: %d)...\n", getpid());

    // --- 1. Signal Registration ---
    
    // Register handler for SIGUSR1 (The "Update Now" signal)
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = handle_sigusr1;
    sigaction(SIGUSR1, &sa, NULL);

    // Register handler for SIGTERM/SIGINT (Graceful Shutdown)
    struct sigaction sa_term;
    memset(&sa_term, 0, sizeof(sa_term));
    sa_term.sa_handler = handle_sigterm;
    sigaction(SIGTERM, &sa_term, NULL);
    sigaction(SIGINT, &sa_term, NULL);

    // --- 2. Main Event Loop ---
    while (!stop_request) {
        
        // Check if the signal handler set the flag
        if (update_request) {
            update_request = 0; // Reset flag
            fetch_router_updates();
        }
        
        // Sleep for 10 seconds to act as a background heartbeat.
        // KEY BEHAVIOR: sleep() is interrupted by signals!
        // If SIGUSR1 arrives at second 2, sleep wakes up immediately,
        // the loop restarts, catches 'if (update_request)', and runs instantly.
        sleep(10);
    }

    printf("[MONITOR] Shutting down...\n");
    return 0;
}
